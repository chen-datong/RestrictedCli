

# This file was *autogenerated* from the file randomSL.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_23 = Integer(23)
class FiniteField:
    def __init__(self, p, n):
        """
        Initialize the finite field GF(p^n).
        p: Prime number (characteristic of the field).
        n: Degree of the field extension (default is 1 for GF(p)).
        """
        self.p = p
        self.n = n
        self.field = GF(p**n, 'a')  # Create the finite field
        self.generator = self.field.gen()  # Find the primitive element
        self.polynomial_basis = self._generate_polynomial_basis()  # Generate polynomial basis
        self.dual_basis = self._generate_dual_basis()  # Generate dual basis

    def generate_elements(self):
        """
        Generate all elements of the finite field.
        """
        return list(self.field)
        
    def find_primitive_element(self):
        """
        Find a primitive element of the finite field.
        A primitive element generates the multiplicative group of the field.
        """
        return self.field.primitive_element()

    def _generate_polynomial_basis(self):
        """
        Generate the polynomial basis {1, a, a^2, ..., a^(n-1)} where a is the primitive element.
        """
        a = self.generator
        return [a**i for i in range(self.n)]

    def _generate_dual_basis(self):
        """
        Generate the dual basis of the polynomial basis.
        The dual basis {b_0, b_1, ..., b_(n-1)} satisfies Tr(b_i * a^j) = Î´_ij (Kronecker delta).
        """
        a = self.generator
        n = self.n
        dual_basis = []
        for j in range(n):
        # Set up the system of equations: Tr(alpha_i * beta_j) = delta_ij
            equations = []
            for i in range(n):
                eq = [self.trace(a**i * a**k) for k in range(n)]
                equations.append(eq)
            
            # Right-hand side: delta_ij (1 if i == j, else 0)
            rhs = [_sage_const_1  if i == j else _sage_const_0  for i in range(n)]
            
            # Solve the system
            coeffs = Matrix(equations).solve_right(vector(rhs))
            
            # Construct the dual basis element
            beta_j = sum(coeffs[k] * a**k for k in range(n))
            dual_basis.append(beta_j)
    
        return dual_basis

    def trace(self, element):
        """
        Compute the trace of an element in the finite field.
        The trace is the sum of the element's conjugates: element + element^p + element^(p^2) + ... + element^(p^(n-1)).
        """
        if element not in self.field:
            raise ValueError("Element must belong to the finite field.")
        trace = element
        current = element
        for _ in range(_sage_const_1 , self.n):
            current = current**self.p  # Raise to the power of p
            trace += current
        return trace

    def express_in_polynomial_basis(self, element):
        """
        Express an element in the polynomial basis {1, a, a^2, ..., a^(n-1)}.
        """
        if element not in self.field:
            raise ValueError("Element must belong to the finite field.")
        coefficients = []
        for basis_element in self.dual_basis:
            coefficients.append(self.trace(element * basis_element))
        return coefficients

    def express_in_dual_basis(self, element):
        """
        Express an element in the dual basis.
        """
        if element not in self.field:
            raise ValueError("Element must belong to the finite field.")
        coefficients = []
        for basis_element in self.polynomial_basis:
            coefficients.append(self.trace(element * basis_element))
        return coefficients

def random_SL_transformation(p,n,XvList,ZvList):
    finite_field = FiniteField(p, n)
    F = finite_field.field
    a = finite_field.generator
    n = finite_field.n
    SL2q = SL(_sage_const_2 , F)
    random_element = SL2q.random_element().matrix()
    new_XvList, new_ZvList = [], []
    for i in range(len(XvList)):
        Xv,Zv = XvList[i], ZvList[i]
        x = sum([finite_field.polynomial_basis[j]*Xv[j] for j in range(n)])
        z = sum([finite_field.dual_basis[j]*Zv[j] for j in range(n)])
        v = vector([x,z])
        new_v = random_element*v
        new_Xv = list(finite_field.express_in_polynomial_basis(new_v[_sage_const_0 ]))
        new_Zv = list(finite_field.express_in_dual_basis(new_v[_sage_const_1 ]))
        new_XvList.append(new_Xv)
        new_ZvList.append(new_Zv)
    return new_XvList, new_ZvList

F = FiniteField(_sage_const_2 ,_sage_const_5 )
print(F.express_in_polynomial_basis(_sage_const_23 ))
print(F.express_in_dual_basis(_sage_const_23 ))

